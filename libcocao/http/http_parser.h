#ifndef __LIBCOCAO_HTTP_PARSER_H__#define __LIBCOCAO_HTTP_PARSER_H__#include "http.h"#include <memory>namespace libcocao {namespace http{class HttpRequestParser {public:    typedef std::shared_ptr<HttpRequestParser> ptr;    /**     * 构造函数     */    HttpRequestParser();    /**     * 解析协议     * @param data 协议文本内存     * @param len 协议文本内存长度     * @return 返回实际解析的长度，并且将已解析的数据移除     */    size_t exectue (char *data, size_t len);    /**     * 是否解析完成     * @return 是否解析完成     */    int isFinished () const { return m_finished; }    /**     * 设置是否解析完成     * @param v     */    void setFinished (bool v) { m_finished = v; }    /**     * 是否有错误     * @return 是否有错误     */    int hasError() const { return !!m_error; }    /**     * 设置错误     * @param v 错误值     */    void setError (int v) { m_error = v; }    /**     * 返回httpRequest结构体     * @return     */    HttpRequest::ptr getData () const { return m_data; }    /**     * 获取http_parser结构体     * @return     */    const http_parser &getParser () const { return m_parser; }    /**     * 获取当前头部field     * @return     */    const std::string &getField() const { return m_field; }    /**     * 设置当前HTTP头部的field     * @param v     */    void setField (const std::string &v) { m_field = v; }public:    /**     * 返回HttpRequest协议解析的缓存大小     * @return     */    static uint64_t GetHttpRequestBufferSize();    /**     * 返回HttpRequest协议的最大消息体大小     * @return     */    static uint64_t GetHttpRequestMaxBodySize();private:    /// http_parser    http_parser m_parser;    /// HttpRequest    HttpRequest::ptr m_data;    /// 错误码，参考http_errno    int error;    /// 是否解析结束    bool m_finished;    /// 当前HTTPtoubu field. http_parser解析HTTP头部field和value分两次返回    std::string m_field;};class HttpResponseParser {public:    typedef std::shared_ptr<HttpResponseParser> ptr;    /**     * 构造函数     */    HttpResponseParser();    /**     * 解析http响应协议     * @param data 协议数据内存     * @param len 协议数据内存大小     * @param chunck 是否在解析chunch     * @return 返回实际解析的长度，并且移除已解析的数据     */    size_t execute (char *data, size_t len);    /**     * 是否解析完成     * @return     */    int isFinished () const { return m_finished;}    /**     * 设置是否解析完成     * @param v     */    void setFinished (bool v) { m_finished = v; }    /**     * 是否有错误`     * @return     */    int hasError () const { return !!m_error; }    /**     * 设置错误码     * @param v 错误码     */    void setError (int v) { m_error = v; }    /**     * 返回HttpResponse     * @return     */    HttpResponse::ptr getData () const { return m_data; }    /**     * 返回http_parser     * @return     */    const http_parser &getParser() const { return m_parser; }    /**     * 获取当前HTTP头部field     * @return     */    const std::string &getField () const { return m_field; }    void setField (const std::string &v) { m_field = v; }private:    /// HTTP响应解析器    http_parser m_parser;    /// HTTP响应对象    HttpResponse::ptr m_data;    /// 错误码    int m_error;    /// 是否解析结束    bool m_finished;    ///当前HTTP头部的field    std::string m_field;};}}#endif