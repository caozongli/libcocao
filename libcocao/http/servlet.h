#ifndef __LIBCOCAO_HTTP_SERVLET_H__#define __LIBCOCAO_HTTP_SERVLET_H__#include <vector>#include <unordered_map>#include "http.h"#include "http_session.h"namespace libcocao {namespace http{class Servlet {public:    typedef std::shared_ptr<Servlet> ptr;    /**     * 构造函数     * @param name     * @return     */    Servlet(const std::string &name)        : m_name(name) {}   /**    * 析构函数    */    virtual ~Servlet () {}    /**     * 处理请求     * @param request HTTP请求     * @param response HTTP响应     * @param session HTTP连接     * @return 是否处理成功     */    virtual int32_t handle (libcocao::http::HttpRequest::ptr request                            , libcocao::http::HttpResponse::ptr response                            , libcocao::http::HttpSession::ptr session) = 0;    const std::string &getName () const { return m_name; }private:    /// 名称    std::string m_name;};/** * 函数式Servlet */ class FunctionServlet : public Servlet { public:     typedef std::shared_ptr<FunctionServlet> ptr;     ///函数回调定义     typedef std::function<int32_t (libcocao::http::HttpRequest::ptr request                                    , libcocao::http::HttpResponse::ptr response                                    , libcocao::http::HttpSession::ptr session)> callback;     /**      * 构造函数      */     FunctionServlet(callback);     virtual int32_t handle(libcocao::http::HttpRequest::ptr request             , libcocao::http::HttpResponse::ptr response             , libcocao::http::HttpSession::ptr session) override; private:     /// 回调函数     callback m_cb; }; class IServletCreator { public:     typedef std::shared_pre<IServletCreator> ptr;     virtual ~IServletCreator(){}     virtual Servlet::ptr get() const = 0;     virtual std::string getName () const = 0; };class HoldServletCreator: public IServletCreator {public:    typedef std::shared_ptr<HoldServletCreator> ptr;    HoldServletCreator(Servlet::ptr slt)        : m_servlet()slt{    }    Servlet::ptr get() const override {        return m_servlet;    }    std::string getName() const override {        return m_servlet->getName();    }private:    Servlet::ptr m_servlet;};template <class T>class ServletCreator : public IServletCreator {public :    typedef std::shared_ptr <ServletCreator> ptr;    ServletCreator() {}    Servlet::ptr get () const override {        return Servlet::ptr (new T);    }    std::string getName() const override {        return TypeToName<T>();    }};class ServletDispatch : public Servlet {public:    typedef std::shared_ptr<ServletDispatch> ptr;    typedef RWMutex RWMutexType;    ServletDispatch();    virtual int32_t handle (libcocao::http::HttpRequest::ptr request            , libcocao::http::HttpResponse::ptr response            , libcocao::http::HttpSession::ptr session) override;    /**     * 添加servlet     * @param uri uri     * @param slt servlet     */    void addServlet (const std::string &uri, Servlet::ptr slt);    /**     * 添加servlet     * @param uri uri     * @param cb FunctionServlet回调函数     */    void addServlet (const std::string &uri, FunctionServlet::callback cb);    /**     * 添加模糊匹配servlet     * @param uri uri模糊匹配 /sylar     * @param slt servlet     */    void addGlobServlet(const std::string &uri, Servlet::ptr slt);        /**     * 添加模糊匹配servlet     * @param uri uri 模糊匹配     * @param cb Functionservlet回调函数     */    void addGlobServlet (const std::string &uri, FunctionServlet::callback cb);    void addServletCreator (const std::string &uri, IServletCreator::ptr creator);    void addGlobServletCreator (const std::string& uri, IServletCreator::ptr creator);        template<class T>    void addServletCreator(const std::string &uri) {        addServletCreator(uri, std::make_shared<ServletCreator<T>>());    }    template<class T >    void addGlobServletCreator (const std::string &uri) {        addGlobServletCreator(uri, std::make_shared<ServletCreator<T>>());    }    /**     * 删除servlet     * @param uri     */    void delServlet (const std::string &uri);    /**     * 删除模糊匹配servlet     * @param uri     */    void delGlobServlet (const std::string &uri);    /**     * 返回默认的servlet     * @return     */    Servlet::ptr getDefault() const { return m_default;}    /**     * 设置默认servlet     * @param v     */    void setDefault (Servlet::ptr v) { m_default = v; }    Servlet::ptr getServlet (const std::string &uri);    /**     * 通过uri获取模糊匹配的servlet     * @param uri     * @return     */    Servlet::ptr getGlobServlet (const std::string &uri);    /**     * 通过uri获取servlet     * @param uri     * @return     */    Servlet::ptr getMatchedServlet (const std::string &uri);    void listAllServletCreator(std::map<std::string, IServletCreator::ptr> &infos);    void listAllGlobServletCreator(std::map <std::string, IServletCreator::ptr> &infos);private:    /// 读写互斥量    RWMutexType m_mutex;    /// 精准匹配servlet MAP    /// uri(/sylr/xxx) -> servlet    std::unordered_map<std::string, IServletCreator::ptr> m_datas;    /// 模糊匹配servlet数组    /// uri（sylsr/*) -> servlet    std::vector<std::pair<std::string, IServletCreator::ptr>> m_globs;    ///默认servlet，所有路径没有匹配到时使用    Servlet::ptr m_default;};class NotFoundServlet : public Servlet {public:    typedef std::shared_ptr <NotFoundServlet> ptr;    NotFoundServlet (const std::string &name) ;    virtual int32_t handle (libcocao::http::HttpRequest::ptr request            , libcocao::http::HttpResponse::ptr response            , libcocao::http::HttpSession::ptr session) override;private:    std::string m_name;    std::string m_content;};}}#endif